\section{剑指 Offer II 005. 单词长度的最大乘积}

\href{https://leetcode.cn/problems/WGki4K/}{Question Link}

描述：给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。

示例：

\begin{lstlisting}
输入: words = ["abcw","baz","foo","bar","fxyz","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "fxyz"。它们不包含相同字符，且长度的乘积最大。
\end{lstlisting}

%------------------------------------------------

\subsection{解析}

因为字符串中只包含英语的小写字母，也就是 a-z，共26个，因此对于每一个字符串，可以使用整数（32位）的每一位记录是否存在对应字母，如果字符串中包含 a，那么整数的第一位应该是1。
记录完成之后，如果两个字符串对应的整数取 \textbf{\&} 的结果为0，那么说明两个字符串不包含相同的字符。

\subsection*{Code:}

\begin{lstlisting}[language=C++]
class Solution {
 public:
  int maxProduct(vector<string>& words) {
    int length = words.size();
    vector<int> masks(length, 0);

    for (int i = 0; i < length; i++) {
      for (char c : words[i]) {
        masks[i] |= (1 << c - 'a');
      }
    }
    int max_prod = 0;
    for (int i = 0; i < length; i++) {
      for (int j = i + 1; j < length; j++) {
        if ((masks[i] & masks[j]) == 0) {
          max_prod = max(max_prod, (int)(words[i].size() * words[j].size()));
        }
      }
    }
    return max_prod;
  }
};
\end{lstlisting}
